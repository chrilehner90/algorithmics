{"version":3,"sources":["suffixTree.js"],"names":[],"mappings":"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","file":"suffixTree-compiled.js","sourcesContent":["class Node {\n  constructor(name, start, end, textIndex) {\n\n    this.name = name; // name just for debugging purposes\n    this.children = []; // array of references to the text\n\n    // reference inside the text\n    this.reference = {\n      start: start,\n      end: end,\n      textIndex: textIndex\n    };\n    this.suffixLink = undefined;\n  }\n\n  addChild(node) {\n    this.children.push(node);\n  }\n\n  set link(node) {\n    this.suffixLink = node;\n  }\n\n  get link() {\n    return this.suffixLink;\n  }\n\n  isLeaf() {\n    return this.children.length === 0;\n  }\n}\n\nclass SuffixTree {\n  constructor() {\n    this.start = 1;\n\n    // collect all inputs\n    this.inputs = [];\n\n    this.virtualRoot = new Node(\"virutalRoot\");\n    this.rootNode = new Node(\"root\");\n\n    // virtualRoot --> root --> virtualRoot\n    this.virtualRoot.addChild(this.rootNode);\n\n    this.rootNode.link = this.virtualRoot;\n\n    this.text = \"\";\n  }\n\n  set input(text) {\n    this.text = text;\n  }\n\n  get input() {\n    return this.text;\n  }\n\n  findChild(node, start) {\n    // find child with correct edge\n    let child = undefined;\n    for (var index in node.children) {\n      let childStartIndex = node.children[index].reference.start;\n      if (input[start] === input[childStartIndex]) {\n        return node.children[index];\n        break;\n      }\n    }\n  }\n\n  buildSuffixTree(input) {\n    this.input = input;\n\n    let activeNode = this.rootNode;\n    for(let i = 1; i < input.length; i++) {\n      // construct T^i from T^i-1\n      let result = this.update(activeNode,  { start: this.start, end: this.start - 1 }, i);\n      //start = result.start;\n      //activeNode = result.activeNode;\n    }\n  }\n\n  update(activeNode, reference, index) {\n    let { start, end } = reference;\n    let lastInsertedNode = this.rootNode;\n    let canonizedNode = undefined;\n    let newStart = 0;\n    ( { activeNode: canonizedNode, start: newStart } = this.canonize(activeNode, { start: start, end: end }) );\n\n    // TODO: add text indices to references in Node class\n    var resultTestAndSplit = this.testAndSplit(canonizedNode, { start: start, end: end }, this.input[index]);\n  }\n\n  canonize(activeNode, reference) {\n    let { start, end } = reference;\n\n    while(end - start + 1 > 0) {\n      let child = findChild(activeNode, start);\n      // check for minimal reference or if child is a leaf\n      let edgeLength = child.reference.end - child.reference.start;\n      if(edgeLength > activeNode.reference.end - activeNode.reference.start || child.isLeaf()) {\n        break;\n      }\n      activeNode = child;\n      start += edgeLength;\n    }\n    return { activeNode: activeNode, start: start };\n  }\n\n  testAndSplit(canonizedNode, reference, character) {\n    let { start, end } = reference;\n    if(start > end) {\n      // explicit reference\n      for(var index in canonizedNode.children) {\n        if(character === this.input[canonizedNode.children[index].reference.start]) {\n          return { done: true, testAndSplitNode: canonizedNode };\n        }\n      }\n      return { done: false, testAndSplitNode: canonizedNode };\n    }\n    else {\n      // implicit reference\n      let child = findChild(canonizedNode, start);\n      if(character === this.input[child.reference.end + 1]) {\n        return { done: true, testAndSplitNode: canonizedNode };\n      }\n      else {\n        let newParent = new Node(\"\", start, end);\n        let newChild = new Node(end + 1, child.reference.end);\n        canonizedNode.addChild(newParent);\n        newParent.addChild(newChild);\n        return { done: false, testAndSplitNode: newParent };\n      }\n    }\n  }\n}\n\nmodule.exports = SuffixTree;"]}