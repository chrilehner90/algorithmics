{"version":3,"sources":["suffixTree.js"],"names":[],"mappings":";;;;;;;;IAAM,IAAI;AACG,WADP,IAAI,CACI,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE;0BADrC,IAAI;;AAGN,QAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACjB,QAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;;;AAGnB,QAAI,CAAC,SAAS,GAAG;AACf,WAAK,EAAE,KAAK;AACZ,SAAG,EAAE,GAAG;AACR,eAAS,EAAE,SAAS;KACrB,CAAC;AACF,QAAI,CAAC,UAAU,GAAG,SAAS,CAAC;GAC7B;;eAbG,IAAI;;WAeA,kBAAC,IAAI,EAAE;AACb,UAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC1B;;;WAcK,kBAAG;AACP,aAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC;KACnC;;;SAdO,aAAC,IAAI,EAAE;AACb,UAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KACxB;SAEO,eAAG;AACT,aAAO,IAAI,CAAC,UAAU,CAAC;KACxB;;;SAEW,eAAG;AACb,aAAO,IAAI,CAAC,IAAI,CAAC;KAClB;;;SA7BG,IAAI;;;IAoCJ,UAAU;AACH,WADP,UAAU,GACA;0BADV,UAAU;;AAEZ,QAAI,CAAC,KAAK,GAAG,CAAC,CAAC;AACf,QAAI,CAAC,WAAW,GAAG,CAAC,CAAC;;;AAGrB,QAAI,CAAC,MAAM,GAAG,EAAE,CAAC;;AAEjB,QAAI,CAAC,WAAW,GAAG,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACjD,QAAI,CAAC,QAAQ,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;;;AAGvC,QAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACzC,QAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC;;AAEtC,QAAI,CAAC,IAAI,GAAG,EAAE,CAAC;GAChB;;eAhBG,UAAU;;WAkCL,mBAAC,IAAI,EAAE,KAAK,EAAE;;AAErB,UAAG,IAAI,KAAK,IAAI,CAAC,WAAW,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC;AACnD,WAAK,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE;AAC/B,YAAI,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC;AAC3D,YAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACnD,iBAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC5B,gBAAM;SACP;OACF;KACF;;;WAEc,yBAAC,KAAK,EAAE;AACrB,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;;AAEnB,UAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACnB,eAAO;OACR;;;;;AAKD,UAAI,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC/B,UAAI,KAAK,GAAG,SAAS,CAAC;AACtB,WAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;sBAGV,IAAI,CAAC,MAAM,CAAC,UAAU,EAAG,IAAI,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;;;;;;;AAAzE,kBAAU;AAAE,aAAK;;AACrB,YAAI,CAAC,UAAU,GAAG,KAAK,CAAC;;OAEzB;;AAED,aAAO,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;KAC5B;;;WAEK,gBAAC,UAAU,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE;AACpC,aAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC;;AAEvD,UAAI,gBAAgB,GAAG,IAAI,CAAC,QAAQ,CAAC;;sBACX,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,EAAE,GAAG,CAAC;;;;AAA3D,gBAAU;AAAE,WAAK;;;;0BAGQ,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;;;;UAAnF,IAAI;UAAE,YAAY;;AACxB,aAAM,CAAC,IAAI,EAAE;;AAEX,YAAI,OAAO,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC3D,YAAI,CAAC,WAAW,EAAE,CAAC;AACnB,oBAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;AAC/B,YAAG,gBAAgB,KAAK,IAAI,CAAC,QAAQ,EAAE;AACrC,0BAAgB,CAAC,IAAI,GAAG,YAAY,CAAC;SACtC;AACD,wBAAgB,GAAG,YAAY,CAAC;;yBACN,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC;;;;AAAhE,kBAAU;AAAE,aAAK;;6BACM,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,EAAE,GAAG,EAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;;;;AAApF,YAAI;AAAE,oBAAY;OACvB;;AAED,UAAG,gBAAgB,KAAK,IAAI,CAAC,QAAQ,EAAE;AACrC,wBAAgB,CAAC,IAAI,GAAG,YAAY,CAAC;OACtC;AACD,aAAO,CAAE,UAAU,EAAE,KAAK,CAAE,CAAC;KAC9B;;;WAEO,kBAAC,UAAU,EAAE,KAAK,EAAE,GAAG,EAAE;AAC/B,aAAO,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC;;AAEzD,aAAM,GAAG,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,EAAE;AACzB,YAAI,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;;AAE9C,YAAI,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC;AACjE,eAAO,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;AAChC,YAAG,KAAK,KAAK,IAAI,CAAC,QAAQ,KAAK,UAAU,GAAG,GAAG,GAAG,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE,CAAA,AAAC,EAAE;AAC1E,gBAAM;SACP;AACD,kBAAU,GAAG,KAAK,CAAC;AACnB,aAAK,IAAI,UAAU,CAAC;OACrB;;AAED,aAAO,CAAE,UAAU,EAAE,KAAK,CAAE,CAAC;KAC9B;;;WAEW,sBAAC,aAAa,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE;AACjD,aAAO,CAAC,GAAG,CAAC,cAAc,EAAE,KAAK,EAAE,GAAG,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;AAChE,UAAG,KAAK,GAAG,GAAG,EAAE;;AAEd,aAAI,IAAI,KAAK,IAAI,aAAa,CAAC,QAAQ,EAAE;AACvC,cAAG,aAAa,KAAK,IAAI,CAAC,WAAW,IAAK,SAAS,KAAK,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,AAAC,EAAE;AACjH,mBAAO,CAAE,IAAI,EAAE,aAAa,CAAE,CAAC;WAChC;SACF;AACD,eAAO,CAAE,KAAK,EAAE,aAAa,CAAE,CAAC;OACjC,MACI;;AAEH,YAAI,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;AACjD,YAAG,SAAS,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;AACpD,iBAAO,CAAE,IAAI,EAAE,aAAa,CAAE,CAAC;SAChC,MACI;AACH,cAAI,SAAS,GAAG,IAAI,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AACzC,cAAI,QAAQ,GAAG,IAAI,IAAI,CAAC,EAAE,EAAE,GAAG,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AAC1D,uBAAa,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;AAClC,mBAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAC7B,iBAAO,CAAE,KAAK,EAAE,SAAS,CAAE,CAAC;SAC7B;OACF;KACF;;;;;;;;;;;;;;;;;;;;;AAAA;;;SAzHQ,aAAC,IAAI,EAAE;AACd,UAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KAClB;SAEQ,eAAG;AACV,aAAO,IAAI,CAAC,IAAI,CAAC;KAClB;;;SAEa,aAAC,KAAK,EAAE;AACpB,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACpB;SAEa,eAAG;AACf,aAAO,IAAI,CAAC,KAAK,CAAC;KACnB;;;SAhCG,UAAU;;;AAkKhB,MAAM,CAAC,OAAO,GAAG,UAAU,CAAC","file":"suffixTree-compiled.js","sourcesContent":["class Node {\n  constructor(name, start, end, textIndex) {\n\n    this.name = name; // name just for debugging purposes\n    this.children = []; // array of references to the text\n\n    // reference inside the text\n    this.reference = {\n      start: start,\n      end: end,\n      textIndex: textIndex\n    };\n    this.suffixLink = undefined;\n  }\n\n  addChild(node) {\n    this.children.push(node);\n  }\n\n  set link(node) {\n    this.suffixLink = node;\n  }\n\n  get link() {\n    return this.suffixLink;\n  }\n\n  get nodeName() {\n    return this.name;\n  }\n\n  isLeaf() {\n    return this.children.length === 0;\n  }\n}\n\nclass SuffixTree {\n  constructor() {\n    this.start = 0;\n    this.nodeCounter = 2;\n\n    // collect all inputs\n    this.inputs = [];\n\n    this.virtualRoot = new Node(\"virtualRoot\", 0, 0);\n    this.rootNode = new Node(\"root\", 0, 0);\n\n    // virtualRoot --> root --> virtualRoot\n    this.virtualRoot.addChild(this.rootNode);\n    this.rootNode.link = this.virtualRoot;\n\n    this.text = \"\";\n  }\n\n  set input(text) {\n    this.text = text;\n  }\n\n  get input() {\n    return this.text;\n  }\n\n  set startIndex(start) {\n    this.start = start;\n  }\n\n  get startIndex() {\n    return this.start;\n  }\n\n  findChild(node, start) {\n    // find child with correct edge\n    if(node === this.virtualRoot) return this.rootNode;\n    for (var index in node.children) {\n      let childStartIndex = node.children[index].reference.start;\n      if (this.text[start] === this.text[childStartIndex]) {\n        return node.children[index];\n        break;\n      }\n    }\n  }\n\n  buildSuffixTree(input) {\n    this.input = input;\n\n    if(input.length < 1) {\n      return;\n    }\n\n    //let child = new Node(this.input[this.startIndex - 1], this.startIndex - 1, Infinity);\n    //this.rootNode.addChild(child);\n\n    let activeNode = this.rootNode;\n    let start = undefined;\n    for(let i = 0; i < input.length; i++) {\n      // construct T^i from T^i-1\n      // activeNode is the real active node\n      ( [ activeNode, start ] = this.update(activeNode,  this.startIndex, i - 1, i) );\n      this.startIndex = start;\n      // now activeNode is the endpoint\n    }\n    //this.print(this.rootNode, 0);\n    console.log(this.rootNode);\n  }\n\n  update(activeNode, start, end, index) {\n    console.log(\"UPDATE\", start, end, activeNode.nodeName);\n\n    let lastInsertedNode = this.rootNode;\n    ( [ activeNode, start ] = this.canonize(activeNode, start, end) );\n\n    // TODO: add text indices to references in Node class\n    let [ done, newInnerNode ] = this.testAndSplit(activeNode, start, end, this.input[index]);\n    while(!done) {\n      //console.log(\"DONE:\", done);\n      let newLeaf = new Node(this.input[index], index, Infinity);\n      this.nodeCounter++;\n      newInnerNode.addChild(newLeaf);\n      if(lastInsertedNode !== this.rootNode) {\n        lastInsertedNode.link = newInnerNode;\n      }\n      lastInsertedNode = newInnerNode;\n      ( [ activeNode, start ] = this.canonize(activeNode.link, start, end) );\n      ( [ done, newInnerNode ] = this.testAndSplit(activeNode, start, end , this.input[index]) );\n    }\n\n    if(lastInsertedNode !== this.rootNode) {\n      lastInsertedNode.link = newInnerNode;\n    }\n    return [ activeNode, start ];\n  }\n\n  canonize(activeNode, start, end) {\n    console.log(\"CANONIZE\", start, end, activeNode.nodeName);\n\n    while(end - start + 1 > 0) {\n      let child = this.findChild(activeNode, start);\n      // check for minimal reference or if child is a leaf\n      let edgeLength = child.reference.end - child.reference.start + 1;\n      console.log(\"EDGE\", edgeLength);\n      if(child !== this.rootNode && (edgeLength > end - start || child.isLeaf())) {\n        break;\n      }\n      activeNode = child;\n      start += edgeLength;\n    }\n\n    return [ activeNode, start ];\n  }\n\n  testAndSplit(canonizedNode, start, end, character) {\n    console.log(\"testAndSplit\", start, end, canonizedNode.nodeName);\n    if(start > end) {\n      // explicit reference\n      for(var index in canonizedNode.children) {\n        if(canonizedNode === this.virtualRoot || (character === this.text[canonizedNode.children[index].reference.start])) {\n          return [ true, canonizedNode ];\n        }\n      }\n      return [ false, canonizedNode ];\n    }\n    else {\n      // implicit reference\n      let child = this.findChild(canonizedNode, start);\n      if(character === this.input[child.reference.end + 1]) {\n        return [ true, canonizedNode ];\n      }\n      else {\n        let newParent = new Node(\"\", start, end);\n        let newChild = new Node(\"\", end + 1, child.reference.end);\n        canonizedNode.addChild(newParent);\n        newParent.addChild(newChild);\n        return [ false, newParent ];\n      }\n    }\n  }\n\n  //print(node, depth) {\n  //  console.log(\"NODE COUNTER\", this.nodeCounter);\n  //  for(let i = 0; i < this.nodeCounter - 1; i++) {\n  //    let child = node.children[i];\n  //    if(child !== undefined) {\n  //      let output = \"\";\n  //      for(let j = 0; j < depth; j++) {\n  //        output += \" \";\n  //      }\n  //      console.log(\"Parent\", node.nodeName);\n  //      for(let j = 0; j < depth; j++) {\n  //        output += \" \";\n  //      }\n  //      output += \"|- Child\";\n  //      console.log(output, node.nodeName);\n  //      this.print(child, depth + 1);\n  //    }\n  //  }\n  //}\n}\n\nmodule.exports = SuffixTree;"]}