{"version":3,"sources":["suffixTree.js"],"names":[],"mappings":"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","file":"suffixTree-compiled.js","sourcesContent":["class Node {\n  constructor(name, start, end, textIndex) {\n\n    this.name = name; // name just for debugging purposes\n    this.children = []; // array of references to the text\n\n    // reference inside the text\n    this.reference = {\n      start: start,\n      end: end,\n      textIndex: textIndex\n    };\n    this.suffixLink = undefined;\n  }\n\n  addChild(node) {\n    this.children.push(node);\n  }\n\n  set link(node) {\n    this.suffixLink = node;\n  }\n\n  get link() {\n    return this.suffixLink;\n  }\n\n  isLeaf() {\n    if(this.children.length === 0) return true\n  }\n}\n\nclass SuffixTree {\n  constructor() {\n    this.start = 1;\n\n    // collect all inputs\n    this.inputs = [];\n\n    this.virtualRoot = new Node(\"virutalRoot\");\n    this.rootNode = new Node(\"root\", this.start, this.start - 1);\n\n    // virtualRoot --> root --> virtualRoot\n    this.virtualRoot.addChild(this.rootNode);\n\n    this.rootNode.link = this.virtualRoot;\n\n    this.text = \"\";\n    \n    console.log(this.virtualRoot);\n\n  }\n\n  set input(text) {\n    this.text = text;\n  }\n\n  get input() {\n    return this.text;\n  }\n\n  buildSuffixTree(input) {\n    this.input = input;\n\n    let activeNode = this.rootNode;\n    for(let i = 1; i < input.length; i++) {\n      // construct T^i from T^i-1\n      let result = this.update(activeNode,  { start: this.start, end: this.start - 1 }, i);\n      //start = result.start;\n      //activeNode = result.activeNode;\n    }\n  }\n\n  update(activeNode, reference, index) {\n    let { start, end } = reference;\n    let lastInsertedNode = this.rootNode;\n    let canonizedNode = this.canonize(activeNode, { start: start, end: end });\n    // TODO: implement testAndSplit function\n    // TODO: add text indices to references in Node class\n    //var resultTestAndSplit = this.testAndSplit(canonizedNode, input, );\n  }\n\n  canonize(activeNode, input) {\n    while(activeNode.reference.end - activeNode.reference.start + 1 > 0) {\n      let child = undefined;\n\n      // find child with correct edge\n      for(var index in activeNode.children) {\n        let childStartIndex = activeNode.children[index].reference.start;\n        if(input[activeNode.reference.start] === input[childStartIndex]) {\n          child = activeNode.children[index];\n          break;\n        }\n      }\n\n      // check for minimal reference or if child is a leaf\n      if(child.reference.end - child.reference.start > activeNode.reference.end - activeNode.reference.start || child.isLeaf()) {\n        break;\n      }\n      activeNode = child;\n      activeNode.reference.start += 1;\n    }\n    return activeNode;\n  }\n\n  testAndSplit() {\n\n  }\n}\n\nmodule.exports = SuffixTree;"]}