{"version":3,"sources":["suffixTree.js"],"names":[],"mappings":"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","file":"suffixTree-compiled.js","sourcesContent":["class Node {\n  constructor(name, start, end, textIndex) {\n\n    this.name = name; // name just for debugging purposes\n    this.children = []; // array of references to the text\n\n    // reference inside the text\n    this.reference = {\n      start: start,\n      end: end,\n      textIndex: textIndex\n    };\n    this.suffixLink = undefined;\n  }\n\n  addChild(node) {\n    this.children.push(node);\n  }\n\n  set link(node) {\n    this.suffixLink = node;\n  }\n\n  get link() {\n    return this.suffixLink;\n  }\n\n  isLeaf() {\n    return this.children.length === 0;\n  }\n}\n\nclass SuffixTree {\n  constructor() {\n    this.start = 1;\n\n    // collect all inputs\n    this.inputs = [];\n\n    this.virtualRoot = new Node(\"virutalRoot\");\n    this.rootNode = new Node(\"root\");\n\n    // virtualRoot --> root --> virtualRoot\n    this.virtualRoot.addChild(this.rootNode);\n\n    this.rootNode.link = this.virtualRoot;\n\n    this.text = \"\";\n  }\n\n  set input(text) {\n    this.text = text;\n  }\n\n  get input() {\n    return this.text;\n  }\n\n  findChild(node, start) {\n    // find child with correct edge\n    let child = undefined;\n    for (var index in node.children) {\n      let childStartIndex = node.children[index].reference.start;\n      if (input[start] === input[childStartIndex]) {\n        return node.children[index];\n        break;\n      }\n    }\n  }\n\n  buildSuffixTree(input) {\n    this.input = input;\n\n    let activeNode = this.rootNode;\n    let start = undefined;\n    for(let i = 1; i < input.length; i++) {\n      // construct T^i from T^i-1\n      // activeNode is the real active node\n      ( [ activeNode, this.start ] = this.update(activeNode,  { start: this.start, end: this.start - 1 }, i) );\n      // now activeNode is the endpoint\n    }\n  }\n\n  update(activeNode, reference, index) {\n    let { start, end } = reference;\n    let lastInsertedNode = this.rootNode;\n    let canonizedNode = undefined;\n    ( [ canonizedNode, start ] = this.canonize(activeNode, start, end) );\n\n    // TODO: add text indices to references in Node class\n    let [ done, newInnerNode ] = this.testAndSplit(canonizedNode, start, end, this.input[index]);\n    while(!done) {\n      //console.log(\"DONE:\", done);\n      let newLeaf = new Node(\"\", index, Infinity);\n      newInnerNode.addChild(newLeaf);\n      if(lastInsertedNode !== this.rootNode) {\n        lastInsertedNode.link = newInnerNode;\n      }\n      lastInsertedNode = newInnerNode;\n      ( [ canonizedNode, start ] = this.canonize(activeNode.link, start, end) );\n      console.log(\"CANONIZED NODE\", canonizedNode);\n      ( [ done, newInnerNode ] = this.testAndSplit(canonizedNode, start, end , this.input[index]) );\n    }\n\n    if(lastInsertedNode !== this.rootNode) {\n      lastInsertedNode.link = newInnerNode;\n    }\n    return [ activeNode, start ];\n  }\n\n  canonize(activeNode, start, end) {\n\n    if(start > end && activeNode === undefined) {\n      activeNode = this.virtualRoot;\n      return { activeNode, start };\n    }\n\n    while(end - start + 1 > 0) {\n      let child = findChild(activeNode, start);\n      // check for minimal reference or if child is a leaf\n      let edgeLength = child.reference.end - child.reference.start;\n      if(edgeLength > activeNode.reference.end - activeNode.reference.start || child.isLeaf()) {\n        break;\n      }\n      activeNode = child;\n      start += edgeLength;\n    }\n\n    return [ activeNode, start ];\n  }\n\n  testAndSplit(canonizedNode, start, end, character) {\n    if(start > end) {\n      // explicit reference\n      for(var index in canonizedNode.children) {\n        console.log(\"EXPLICIT\");\n        if(character === this.text[canonizedNode.children[index].reference.start]) {\n          console.log(\"TRUE\");\n          return [ true, canonizedNode ];\n        }\n      }\n      return [ false, canonizedNode ];\n    }\n    else {\n      // implicit reference\n      console.log(\"IMPLICIT\");\n      let child = findChild(canonizedNode, start);\n      if(character === this.input[child.reference.end + 1]) {\n        return [ true, canonizedNode ];\n      }\n      else {\n        let newParent = new Node(\"\", start, end);\n        let newChild = new Node(end + 1, child.reference.end);\n        canonizedNode.addChild(newParent);\n        newParent.addChild(newChild);\n        return [ false, newParent ];\n      }\n    }\n  }\n}\n\nmodule.exports = SuffixTree;"]}